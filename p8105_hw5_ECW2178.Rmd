---
title: "p8105_hw5_ECW2178"
output: github_document
date: "2025-11-13"
---

```{r libraries_datasets}
library(tidyverse)
library(rvest)
```

```{r problem_1}
set.seed(343215)

bday_sim = function(n_room){
  birthdays = sample(1:365, n_room, replace = TRUE)
  repeated_bday = length(unique(birthdays)) < n_room
  repeated_bday
}

bday_sim(20)

bday_sim_results = 
  expand_grid(
    bdays = 2:50,
    iter = 1:10000
  ) %>% 
  mutate(
    result = map_lgl(bdays, bday_sim)
  ) %>% 
  group_by(bdays) %>% 
  summarize(
    prob_repeat = mean(result)
  )

bday_sim_results %>% 
  ggplot(aes(x = bdays, y = prob_repeat)) +
  geom_point() + 
  geom_line()
```

As expected, as the number in each group increases, there is a gradual increase in the probability of a repeated birthday. However, this increase is unexpectedly large- once there is more than 22 people in a group, there is a greater than 50% chance of a repeated birthday. 

```{r problem_2}
# ok so to solve this you need to run it six times but each time it goes with a different value in the list 
#so when you create a function to run it 
#but when you call the function, it needs to be a list 
#but it needs to be in a for loop as well?

mu_list = c(0, 1, 2, 3, 4, 5, 6) 

#output = vector("list", length = 5000)

dataset_generator = function(mu){
  n = 30
  sigma = 5
  
  sample = rnorm(n, mu, sigma)
  result = t.test(sample, mu = 0) %>% 
    broom::tidy()
  
  
  return(list(
    estimate = result$estimate,
    pvalue = result$p.value))
  
  # extract_result = tibble(
  #   estimate = result$estimate,
  #   p.value = result$p.value
  # )
}

# power_example = function(mu){ 
# }

run_many = function(mu){
  out = vector("list", 5000)
  for (i in 1:5000){
    out [[i]] = dataset_generator(mu)
  }
  return(out)
}

all_results = vector("list", length(mu_list))

for (i in 1:length(mu_list)){
  all_results[[i]] = run_many(mu_list[i])
}

# for (i in 1:length(mu_list)){
#   mu_value = mu_list[i]
#   simulations = all_results[i]
#   
# }


results_df = data.frame(estimate = numeric(),
                         pvalue = numeric(),
                         true_mu = numeric())

for (i in 1:length(mu_list)) {
  
  mu_value = mu_list[i]
  sims = all_results[[i]]  
  
  for (j in 1:length(sims)) {
    results_df = rbind(results_df,
                        data.frame(
                          estimate = sims[[j]]$estimate,
                          pvalue = sims[[j]]$pvalue,
                          true_mu = mu_value
                        ))
  }
}
```


The homicides raw dataset contains details of the arrests on individuals made across cities in the United States such as arrest ID, date of arrest, name, demographics, city, exact location, and disposition. 

```{r problem_3}
homicides_raw = read_csv("https://raw.githubusercontent.com/washingtonpost/data-homicides/master/homicide-data.csv") 

homicides = homicides_raw %>% 
  mutate(city_state = paste(city, state, sep = ", ")) %>% 
  group_by(city_state) %>% 
  summarize(
    homicides = n(),
    unsolved = sum(disposition %in% c("Closed without arrest", "Open/No arrest"))
  )

baltimore_homicides = homicides %>%
  filter(city_state == "Baltimore, MD")

baltimore_result = prop.test(baltimore_homicides$unsolved , baltimore_homicides$homicides) %>% 
    broom::tidy() %>%
    select(estimate, conf.low, conf.high)


city_results = homicides %>% 
  mutate(
    test = map2(unsolved, homicides, ~ prop.test(.x, .y)),
    tidy = map(test, broom::tidy)
  ) %>% 
  select(city_state, tidy) %>% 
  unnest(tidy) %>% 
  select(city_state, estimate, conf.low, conf.high)

city_results_plot = city_results %>% 
  arrange(estimate) %>% 
  mutate(city_state = factor(city_state, levels = city_state)) %>%  
  ggplot(aes(x = estimate, y = city_state)) +
  geom_point() +
  geom_errorbar(aes(xmin = conf.low, xmax = conf.high), width = 0.2) +
  labs(
    x = "Proportion of Unsolved Homicides",
    y = "City",
    title = "Estimated Proportion of Unsolved Homicides by City"
  )
city_results_plot

# ok give a list of the cities 
# create a function 
# run it for each in the list 

# cities = homicides$city_state

# homicides_by_city = function(city){
#   city_homicides = homicides %>% 
#     filter(city_state == city)
#   
#   city_result = prop.test(city_homicides$unsolved , city_homicides$homicides) %>% 
#     broom::tidy() %>% 
#     select(estimate, conf.low, conf.high) %>% 
#     mutate(city_state = city)
#   
#   return(city_result)
# }

#results = map_dfr(cities, homicides_by_city)




# output_list = vector("list", length(cities))
# 
# for (i in 1:length(cities)){
#   output_list[[i]] = homicides_by_city(cities[i])
# }
```

